/**
 *	\file
 */

#pragma once

#include "offer.hpp"
#include "offer_factory.hpp"
#include "shared_library_factory.hpp"
#include "shared_library_offer_factory_observer.hpp"
#include <boost/dll/shared_library.hpp>
#include <deque>
#include <exception>
#include <memory>
#include <stdexcept>
#include <string>
#include <typeinfo>

namespace module_loader {

/**
 *	Creates \ref offer objects by invoking a function
 *	found in a shared library.
 *
 *	The function in each shared library is expected to
 *	take a reference to an instance of this class as
 *	its first and only parameter.
 */
class shared_library_offer_factory : public offer_factory {
private:
	shared_library_factory & slf_;
	shared_library_offer_factory_observer * o_;
	std::deque<std::unique_ptr<offer>> offers_;
	boost::dll::shared_library curr_;
	std::string name_;
	bool next_active_;
	bool get_offers ();
	std::unique_ptr<offer> next_impl ();
	void check_add () const;
	void dispatch_add (const offer &);
	void dispatch_begin_load ();
	void dispatch_end_load();
public:
	/**
	 *	Thrown when an exception is thrown from a function
	 *	invoked in the shared library.
	 *
	 *	This is done due to the fact that code in the shared
	 *	library may thrown an exception of a type defined
	 *	in that shared library.  In that case the shared
	 *	library may be unloaded while the exception is in
	 *	flight, which will cause a segmentation fault when
	 *	any code related to that exception is executed.
	 */
	class error : public std::runtime_error {
	private:
		const std::type_info * type_;
		std::string what_;
		boost::dll::shared_library so_;
	public:
		error (const std::type_info &, std::string, boost::dll::shared_library);
		error (const std::exception &, boost::dll::shared_library);
	};
	shared_library_offer_factory () = delete;
	/**
	 *	Creates a new shared_library_offer_factory which
	 *	acquires boost::dll::shared_library objects from
	 *	a certain \ref shared_library_factory.
	 *
	 *	&quot;load&quot; will be the name of the function
	 *	invoked in each shared_library encountered.
	 *
	 *	\param [in] slf
	 *		The \ref shared_library_factory.
	 */
	explicit shared_library_offer_factory (shared_library_factory & slf);
	/**
	 *	Creates a new shared_library_offer_factory which
	 *	acquires boost::dll::shared_library objects from
	 *	a certain \ref shared_library_factory and which is
	 *	observed by a certain \ref shared_library_offer_factory_observer.
	 *
	 *	&quot;load&quot; will be the name of the function
	 *	invoked in each shared_library encountered.
	 *
	 *	\param [in] slf
	 *		The \ref shared_library_factory.
	 *	\parm [in] o
	 *		The \ref shared_library_offer_factory_observer.
	 */
	explicit shared_library_offer_factory (shared_library_factory & slf, shared_library_offer_factory_observer & o);
	virtual std::unique_ptr<offer> next () override;
	virtual std::shared_ptr<offer> next_shared () override;
	/**
	 *	Adds an \ref offer to the collection of
	 *	\ref offer objects generated by the shared
	 *	library currently being loaded.  If invoked
	 *	from outside the load handler of a shared
	 *	library the behavior is undefined.
	 *
	 *	\param [in] o
	 *		A smart pointer to the \ref offer.
	 */
	void add (std::unique_ptr<offer> o);
	void add (std::shared_ptr<offer> o);
};

}
